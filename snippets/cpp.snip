### include
snippet     include<>
abbr        #include <bits/stdc++.h>
  #include <${1:bits/stdc++.h}>$0

### include
snippet     include""
abbr        #include ""
  #include "${1}"$0

### main
snippet     main()
abbr        main
#options     head
  #include <bits/stdc++.h>
  #define FOR(i,b,e) for (common_type_t <decltype (b), decltype (e)> i = (b), i ## __end = (e); i < i ## __end; ++ i)
  #define FORR(i,b,e) for (common_type_t <decltype (b), decltype (e)> i = (e), i ## __begin = (b); i -- > i ## __begin;)
  #define rep(i,n) for (decay_t <decltype (n)> i = 0, i ## __len = (n); i < i ## __len; ++ i)
  #define ALL(x) begin (x), end (x)
  using namespace std;
  
  auto main () -> int
  {
    cin.tie (nullptr);
    ios::sync_with_stdio (false);
  
    $0
  }

### if
snippet     if()
abbr        if
  if (${1:#:/* condition */})$0

### else if
snippet     else-if()
abbr        else if
  else if (${1:#:/* condition */})$0

### while
snippet     while()
abbr        while
  while (${1:#:/* condition */})$0

### do-while
snippet     do-while();
abbr        do-while
  do
  {
    $0
  } while (${1:#:/* condition */});

### for loop
snippet     for-loop
abbr        for loop
  for (${1:auto} ${2:i} = ${3:0}; $2 < ${4:n}; ++ $2)$0

### for loop with iterator
snippet     for-loop-iterator
abbr        for loop with iterator
  for (${1:auto} ${2:ite} = begin (${3:vec}); $2 != end ($3); ++ $2)$0

### range-based for
snippet     range-based-for-loop
abbr        range-based for loop
#alias       for-range-based
  for (auto && ${1:elem} : ${2:v})$0

snippet     for-range-based
abbr        range-based for loop
  for (auto && ${1:elem} : ${2:v})$0

### switch
snippet     switch()
abbr        switch
  switch (${1:#:/* expression */})
  {
  $0
  default:
  }

### case
snippet     case:
abbr        case
options     indent
  case ${1:#:/* integral constant */}:$0

### goto
snippet     goto-statement
abbr        goto
  goto ${1:label};$0

### return
snippet     return-statement
abbr        return
  return ${1:res};$0

### try catch
snippet     try-catch
abbr        try catch
  try
  {
    $0
  }
  catch (const ${1:exception} & ${2:e})
  {
    cerr << $2.what () << endl;
  }

### throw
snippet     throw-statement
abbr        throw
  throw ${1:#:/* exception */};$0

### sizeof
snippet     sizeof()
abbr        sizeof
options     word
  sizeof (${1:#:/* expression */})$0

### alignof
snippet     alignof()
abbr        alignof
options     word
  alignof (${1:#:/* expression */})$0

### decltype
snippet     decltype()
abbr        decltype
options     word
  decltype (${1:#:/* expression */})$0

### noexcept
snippet     noexcept()
abbr        noexcept
options     word
  noexcept (${1:#:/* expression */})$0

### static_cast
snippet     static_cast<>()
abbr        static_cast
options     word
  static_cast <${1:#:/* type */}> (${2:#:/* expression */})$0

### static_assert
snippet     static_assert()
abbr        static_assert
  static_assert (${1:#:/* condition */});$0

### namespace
snippet     namespace{}
abbr        namespace
  namespace ${1:detail}
  {
    $0
  } // namespace $1

### template
snippet     template<>
abbr        template
  template <$0>

### lambda
snippet     lambda-expression
abbr        lambda
options     word
  [&] (auto && ${1:x}) {
    return $1;$0
  }

### lambda recursive
snippet     lambda-expression-recursive
abbr        lambda-recursive
options     word
  auto ${1:f} = [&] (auto self, auto && ${2:x}) {
    return self (self, $2);
  };

### function
snippet     function
abbr        function
  inline ${2:constexpr }auto ${1:f} ()${3: noexcept}
  {
    $0
  }

### auto&&
snippet     auto&&
abbr        auto &&
options     word
  auto &&$0

### structured binding
snippet     structured-binding-declaration
abbr        structured binding
#alias       auto-structured-binding
  auto && [${1:_}] = ${2:/* tuple or array */};$0

snippet     auto-structured-binding
abbr        structured binding
  auto && [${1:_}] = ${2:/* tuple or array */};$0

### iterator pair
snippet     iterator-pair
abbr        begin (), end ()
#alias       ALL
options     word
  begin (${1:v}), end ($1)$0

### iterator pair
snippet     ALL()
abbr        begin (), end ()
options     word
  begin (${1:v}), end ($1)$0

### iterator pair of istream
snippet     istreambuf_iterator<char>-pair
abbr        iterator pair of istreambuf_iterator
options     word
  (istreambuf_iterator <char> (${1:cin})), istreambuf_iterator <char> ()$0

### input with cin
snippet     cin>>
abbr        input with cin
  ${1:size_t} ${2:n}; cin >> $2;$0

### input vector
snippet     input-vector
abbr        input vector
  vector <${1:int64_t}> ${2:v} (${3:n});
  for (auto && elem : $2) cin >> elem;$0

### output with cout
snippet     cout<<T
abbr        output with cout
  cout << ${1:ans} << endl;$0

### output double with cout
snippet     cout<<double
abbr        output double with cout
  cout << fixed << setprecision (15) << ${1:ans} << endl;$0

### output bool with cout
snippet     cout<<bool
abbr        outout bool with cout
  cout << (${1:ans} ? "${2:true}" : "${3:false}") << endl;$0

### input with istream_iterator
snippet     input-with-istream_iterator
abbr        input with istream_iterator
  copy_n (istream_iterator <iterator_traits <decltype (begin ($1))>::value_type> (cin), ${2:n}, back_inserter (${1:v}));$0

### output with ostream_iterator
snippet     output-with-ostream_iterator
abbr        output with ostream_iterator
  copy (begin (${1:ans}), end ($1), ostream_iterator <iterator_traits <decltype (begin ($1))>::value_type> (${2:cout}, " "));
  $2 << endl;$0

### unique
snippet     unique()
abbr        unique
  ${1:v}.erase (unique ($1.begin (), $1.end ()), $1.end ());$0

### sum
snippet     sum()
abbr        sum of
  accumulate (begin (${1:v}), end ($1), typename iterator_traits <decltype (begin ($1))>::value_type {});$0

### define FOR
snippet     define-FOR
abbr        define FOR
  #define FOR(i,b,e) for (common_type_t <decltype (b), decltype (e)> i = (b), i ## __end = (e); i < i ## __end; ++ i)$0

### define rep
snippet     define-rep
abbr        define rep
  #define rep(i,n) for (decay_t <decltype (n)> i = 0, i ## __len = (n); i < i ## __len; ++ i)$0

### define ALL
snippet     define-ALL
abbr        define ALL
  #define ALL(x) begin (x), end (x)$0

### define dump
snippet     define-dump
abbr        define dump
  #define dump(x) cerr << #x " = " << boolalpha << (x) << endl;$0

### define inf
snippet     define-inf
abbr        define inf [constexpr]
  template <typename T = int64_t>
  static constexpr auto inf = static_cast <T> (0x0de0b6b43b9aca00);$0

### define EPS
snippet     define-EPS
abbr        define EPS [constexpr]
  static constexpr auto EPS = 1e-9;$0

### include guard
snippet     include-guard
abbr        include-guard
  #ifndef ${1:#:/* macro */}
  #define $1
  $0
  #endif // $1

### #ifdef ~ #endif
snippet     ifdef-endif
abbr        #ifdef ~ #endif
  #ifdef ${1:LOCAL}
  $0
  #endif

### define operator << (ostream &, const T &)
snippet     operator<<ostream
abbr        define operator << (ostream)
  ${1:template <typename T>}
  inline auto operator << (ostream & stream, const ${2:vector <T>} & x) -> ostream &
  {
    ostream_join (begin (x), end (x), stream, " ");$0
    return stream;
  }

